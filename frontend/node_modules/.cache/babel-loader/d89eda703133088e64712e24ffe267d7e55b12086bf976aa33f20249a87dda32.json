{"ast":null,"code":"import { clamp, getDistances, getRandom } from \"tsparticles-engine\";\nexport function applyDistance(particle) {\n  const initialPosition = particle.initialPosition,\n        {\n    dx,\n    dy\n  } = getDistances(initialPosition, particle.position),\n        dxFixed = Math.abs(dx),\n        dyFixed = Math.abs(dy),\n        hDistance = particle.retina.maxDistance.horizontal,\n        vDistance = particle.retina.maxDistance.vertical;\n\n  if (!hDistance && !vDistance) {\n    return;\n  }\n\n  if ((hDistance && dxFixed >= hDistance || vDistance && dyFixed >= vDistance) && !particle.misplaced) {\n    particle.misplaced = !!hDistance && dxFixed > hDistance || !!vDistance && dyFixed > vDistance;\n\n    if (hDistance) {\n      particle.velocity.x = particle.velocity.y / 2 - particle.velocity.x;\n    }\n\n    if (vDistance) {\n      particle.velocity.y = particle.velocity.x / 2 - particle.velocity.y;\n    }\n  } else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {\n    particle.misplaced = false;\n  } else if (particle.misplaced) {\n    const pos = particle.position,\n          vel = particle.velocity;\n\n    if (hDistance && (pos.x < initialPosition.x && vel.x < 0 || pos.x > initialPosition.x && vel.x > 0)) {\n      vel.x *= -getRandom();\n    }\n\n    if (vDistance && (pos.y < initialPosition.y && vel.y < 0 || pos.y > initialPosition.y && vel.y > 0)) {\n      vel.y *= -getRandom();\n    }\n  }\n}\nexport function spin(particle, moveSpeed) {\n  const container = particle.container;\n\n  if (!particle.spin) {\n    return;\n  }\n\n  const updateFunc = {\n    x: particle.spin.direction === \"clockwise\" ? Math.cos : Math.sin,\n    y: particle.spin.direction === \"clockwise\" ? Math.sin : Math.cos\n  };\n  particle.position.x = particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle);\n  particle.position.y = particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle);\n  particle.spin.radius += particle.spin.acceleration;\n  const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height);\n\n  if (particle.spin.radius > maxCanvasSize / 2) {\n    particle.spin.radius = maxCanvasSize / 2;\n    particle.spin.acceleration *= -1;\n  } else if (particle.spin.radius < 0) {\n    particle.spin.radius = 0;\n    particle.spin.acceleration *= -1;\n  }\n\n  particle.spin.angle += moveSpeed / 100 * (1 - particle.spin.radius / maxCanvasSize);\n}\nexport function applyPath(particle, delta) {\n  var _a;\n\n  const particlesOptions = particle.options,\n        pathOptions = particlesOptions.move.path,\n        pathEnabled = pathOptions.enable;\n\n  if (!pathEnabled) {\n    return;\n  }\n\n  if (particle.lastPathTime <= particle.pathDelay) {\n    particle.lastPathTime += delta.value;\n    return;\n  }\n\n  const path = (_a = particle.pathGenerator) === null || _a === void 0 ? void 0 : _a.generate(particle);\n\n  if (path) {\n    particle.velocity.addTo(path);\n  }\n\n  if (pathOptions.clamp) {\n    particle.velocity.x = clamp(particle.velocity.x, -1, 1);\n    particle.velocity.y = clamp(particle.velocity.y, -1, 1);\n  }\n\n  particle.lastPathTime -= particle.pathDelay;\n}\nexport function getProximitySpeedFactor(particle) {\n  return particle.slow.inRange ? particle.slow.factor : 1;\n}","map":{"version":3,"names":["clamp","getDistances","getRandom","applyDistance","particle","initialPosition","dx","dy","position","dxFixed","Math","abs","dyFixed","hDistance","retina","maxDistance","horizontal","vDistance","vertical","misplaced","velocity","x","y","pos","vel","spin","moveSpeed","container","updateFunc","direction","cos","sin","center","radius","angle","acceleration","maxCanvasSize","max","canvas","size","width","height","applyPath","delta","_a","particlesOptions","options","pathOptions","move","path","pathEnabled","enable","lastPathTime","pathDelay","value","pathGenerator","generate","addTo","getProximitySpeedFactor","slow","inRange","factor"],"sources":["/Users/ronciszewski/Desktop/Programming/SmartBrain/face-recognition-app/node_modules/tsparticles-move-base/esm/Utils.js"],"sourcesContent":["import { clamp, getDistances, getRandom } from \"tsparticles-engine\";\nexport function applyDistance(particle) {\n    const initialPosition = particle.initialPosition, { dx, dy } = getDistances(initialPosition, particle.position), dxFixed = Math.abs(dx), dyFixed = Math.abs(dy), hDistance = particle.retina.maxDistance.horizontal, vDistance = particle.retina.maxDistance.vertical;\n    if (!hDistance && !vDistance) {\n        return;\n    }\n    if (((hDistance && dxFixed >= hDistance) || (vDistance && dyFixed >= vDistance)) && !particle.misplaced) {\n        particle.misplaced = (!!hDistance && dxFixed > hDistance) || (!!vDistance && dyFixed > vDistance);\n        if (hDistance) {\n            particle.velocity.x = particle.velocity.y / 2 - particle.velocity.x;\n        }\n        if (vDistance) {\n            particle.velocity.y = particle.velocity.x / 2 - particle.velocity.y;\n        }\n    }\n    else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {\n        particle.misplaced = false;\n    }\n    else if (particle.misplaced) {\n        const pos = particle.position, vel = particle.velocity;\n        if (hDistance && ((pos.x < initialPosition.x && vel.x < 0) || (pos.x > initialPosition.x && vel.x > 0))) {\n            vel.x *= -getRandom();\n        }\n        if (vDistance && ((pos.y < initialPosition.y && vel.y < 0) || (pos.y > initialPosition.y && vel.y > 0))) {\n            vel.y *= -getRandom();\n        }\n    }\n}\nexport function spin(particle, moveSpeed) {\n    const container = particle.container;\n    if (!particle.spin) {\n        return;\n    }\n    const updateFunc = {\n        x: particle.spin.direction === \"clockwise\" ? Math.cos : Math.sin,\n        y: particle.spin.direction === \"clockwise\" ? Math.sin : Math.cos,\n    };\n    particle.position.x = particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle);\n    particle.position.y = particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle);\n    particle.spin.radius += particle.spin.acceleration;\n    const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height);\n    if (particle.spin.radius > maxCanvasSize / 2) {\n        particle.spin.radius = maxCanvasSize / 2;\n        particle.spin.acceleration *= -1;\n    }\n    else if (particle.spin.radius < 0) {\n        particle.spin.radius = 0;\n        particle.spin.acceleration *= -1;\n    }\n    particle.spin.angle += (moveSpeed / 100) * (1 - particle.spin.radius / maxCanvasSize);\n}\nexport function applyPath(particle, delta) {\n    var _a;\n    const particlesOptions = particle.options, pathOptions = particlesOptions.move.path, pathEnabled = pathOptions.enable;\n    if (!pathEnabled) {\n        return;\n    }\n    if (particle.lastPathTime <= particle.pathDelay) {\n        particle.lastPathTime += delta.value;\n        return;\n    }\n    const path = (_a = particle.pathGenerator) === null || _a === void 0 ? void 0 : _a.generate(particle);\n    if (path) {\n        particle.velocity.addTo(path);\n    }\n    if (pathOptions.clamp) {\n        particle.velocity.x = clamp(particle.velocity.x, -1, 1);\n        particle.velocity.y = clamp(particle.velocity.y, -1, 1);\n    }\n    particle.lastPathTime -= particle.pathDelay;\n}\nexport function getProximitySpeedFactor(particle) {\n    return particle.slow.inRange ? particle.slow.factor : 1;\n}\n"],"mappings":"AAAA,SAASA,KAAT,EAAgBC,YAAhB,EAA8BC,SAA9B,QAA+C,oBAA/C;AACA,OAAO,SAASC,aAAT,CAAuBC,QAAvB,EAAiC;EACpC,MAAMC,eAAe,GAAGD,QAAQ,CAACC,eAAjC;EAAA,MAAkD;IAAEC,EAAF;IAAMC;EAAN,IAAaN,YAAY,CAACI,eAAD,EAAkBD,QAAQ,CAACI,QAA3B,CAA3E;EAAA,MAAiHC,OAAO,GAAGC,IAAI,CAACC,GAAL,CAASL,EAAT,CAA3H;EAAA,MAAyIM,OAAO,GAAGF,IAAI,CAACC,GAAL,CAASJ,EAAT,CAAnJ;EAAA,MAAiKM,SAAS,GAAGT,QAAQ,CAACU,MAAT,CAAgBC,WAAhB,CAA4BC,UAAzM;EAAA,MAAqNC,SAAS,GAAGb,QAAQ,CAACU,MAAT,CAAgBC,WAAhB,CAA4BG,QAA7P;;EACA,IAAI,CAACL,SAAD,IAAc,CAACI,SAAnB,EAA8B;IAC1B;EACH;;EACD,IAAI,CAAEJ,SAAS,IAAIJ,OAAO,IAAII,SAAzB,IAAwCI,SAAS,IAAIL,OAAO,IAAIK,SAAjE,KAAgF,CAACb,QAAQ,CAACe,SAA9F,EAAyG;IACrGf,QAAQ,CAACe,SAAT,GAAsB,CAAC,CAACN,SAAF,IAAeJ,OAAO,GAAGI,SAA1B,IAAyC,CAAC,CAACI,SAAF,IAAeL,OAAO,GAAGK,SAAvF;;IACA,IAAIJ,SAAJ,EAAe;MACXT,QAAQ,CAACgB,QAAT,CAAkBC,CAAlB,GAAsBjB,QAAQ,CAACgB,QAAT,CAAkBE,CAAlB,GAAsB,CAAtB,GAA0BlB,QAAQ,CAACgB,QAAT,CAAkBC,CAAlE;IACH;;IACD,IAAIJ,SAAJ,EAAe;MACXb,QAAQ,CAACgB,QAAT,CAAkBE,CAAlB,GAAsBlB,QAAQ,CAACgB,QAAT,CAAkBC,CAAlB,GAAsB,CAAtB,GAA0BjB,QAAQ,CAACgB,QAAT,CAAkBE,CAAlE;IACH;EACJ,CARD,MASK,IAAI,CAAC,CAACT,SAAD,IAAcJ,OAAO,GAAGI,SAAzB,MAAwC,CAACI,SAAD,IAAcL,OAAO,GAAGK,SAAhE,KAA8Eb,QAAQ,CAACe,SAA3F,EAAsG;IACvGf,QAAQ,CAACe,SAAT,GAAqB,KAArB;EACH,CAFI,MAGA,IAAIf,QAAQ,CAACe,SAAb,EAAwB;IACzB,MAAMI,GAAG,GAAGnB,QAAQ,CAACI,QAArB;IAAA,MAA+BgB,GAAG,GAAGpB,QAAQ,CAACgB,QAA9C;;IACA,IAAIP,SAAS,KAAMU,GAAG,CAACF,CAAJ,GAAQhB,eAAe,CAACgB,CAAxB,IAA6BG,GAAG,CAACH,CAAJ,GAAQ,CAAtC,IAA6CE,GAAG,CAACF,CAAJ,GAAQhB,eAAe,CAACgB,CAAxB,IAA6BG,GAAG,CAACH,CAAJ,GAAQ,CAAvF,CAAb,EAAyG;MACrGG,GAAG,CAACH,CAAJ,IAAS,CAACnB,SAAS,EAAnB;IACH;;IACD,IAAIe,SAAS,KAAMM,GAAG,CAACD,CAAJ,GAAQjB,eAAe,CAACiB,CAAxB,IAA6BE,GAAG,CAACF,CAAJ,GAAQ,CAAtC,IAA6CC,GAAG,CAACD,CAAJ,GAAQjB,eAAe,CAACiB,CAAxB,IAA6BE,GAAG,CAACF,CAAJ,GAAQ,CAAvF,CAAb,EAAyG;MACrGE,GAAG,CAACF,CAAJ,IAAS,CAACpB,SAAS,EAAnB;IACH;EACJ;AACJ;AACD,OAAO,SAASuB,IAAT,CAAcrB,QAAd,EAAwBsB,SAAxB,EAAmC;EACtC,MAAMC,SAAS,GAAGvB,QAAQ,CAACuB,SAA3B;;EACA,IAAI,CAACvB,QAAQ,CAACqB,IAAd,EAAoB;IAChB;EACH;;EACD,MAAMG,UAAU,GAAG;IACfP,CAAC,EAAEjB,QAAQ,CAACqB,IAAT,CAAcI,SAAd,KAA4B,WAA5B,GAA0CnB,IAAI,CAACoB,GAA/C,GAAqDpB,IAAI,CAACqB,GAD9C;IAEfT,CAAC,EAAElB,QAAQ,CAACqB,IAAT,CAAcI,SAAd,KAA4B,WAA5B,GAA0CnB,IAAI,CAACqB,GAA/C,GAAqDrB,IAAI,CAACoB;EAF9C,CAAnB;EAIA1B,QAAQ,CAACI,QAAT,CAAkBa,CAAlB,GAAsBjB,QAAQ,CAACqB,IAAT,CAAcO,MAAd,CAAqBX,CAArB,GAAyBjB,QAAQ,CAACqB,IAAT,CAAcQ,MAAd,GAAuBL,UAAU,CAACP,CAAX,CAAajB,QAAQ,CAACqB,IAAT,CAAcS,KAA3B,CAAtE;EACA9B,QAAQ,CAACI,QAAT,CAAkBc,CAAlB,GAAsBlB,QAAQ,CAACqB,IAAT,CAAcO,MAAd,CAAqBV,CAArB,GAAyBlB,QAAQ,CAACqB,IAAT,CAAcQ,MAAd,GAAuBL,UAAU,CAACN,CAAX,CAAalB,QAAQ,CAACqB,IAAT,CAAcS,KAA3B,CAAtE;EACA9B,QAAQ,CAACqB,IAAT,CAAcQ,MAAd,IAAwB7B,QAAQ,CAACqB,IAAT,CAAcU,YAAtC;EACA,MAAMC,aAAa,GAAG1B,IAAI,CAAC2B,GAAL,CAASV,SAAS,CAACW,MAAV,CAAiBC,IAAjB,CAAsBC,KAA/B,EAAsCb,SAAS,CAACW,MAAV,CAAiBC,IAAjB,CAAsBE,MAA5D,CAAtB;;EACA,IAAIrC,QAAQ,CAACqB,IAAT,CAAcQ,MAAd,GAAuBG,aAAa,GAAG,CAA3C,EAA8C;IAC1ChC,QAAQ,CAACqB,IAAT,CAAcQ,MAAd,GAAuBG,aAAa,GAAG,CAAvC;IACAhC,QAAQ,CAACqB,IAAT,CAAcU,YAAd,IAA8B,CAAC,CAA/B;EACH,CAHD,MAIK,IAAI/B,QAAQ,CAACqB,IAAT,CAAcQ,MAAd,GAAuB,CAA3B,EAA8B;IAC/B7B,QAAQ,CAACqB,IAAT,CAAcQ,MAAd,GAAuB,CAAvB;IACA7B,QAAQ,CAACqB,IAAT,CAAcU,YAAd,IAA8B,CAAC,CAA/B;EACH;;EACD/B,QAAQ,CAACqB,IAAT,CAAcS,KAAd,IAAwBR,SAAS,GAAG,GAAb,IAAqB,IAAItB,QAAQ,CAACqB,IAAT,CAAcQ,MAAd,GAAuBG,aAAhD,CAAvB;AACH;AACD,OAAO,SAASM,SAAT,CAAmBtC,QAAnB,EAA6BuC,KAA7B,EAAoC;EACvC,IAAIC,EAAJ;;EACA,MAAMC,gBAAgB,GAAGzC,QAAQ,CAAC0C,OAAlC;EAAA,MAA2CC,WAAW,GAAGF,gBAAgB,CAACG,IAAjB,CAAsBC,IAA/E;EAAA,MAAqFC,WAAW,GAAGH,WAAW,CAACI,MAA/G;;EACA,IAAI,CAACD,WAAL,EAAkB;IACd;EACH;;EACD,IAAI9C,QAAQ,CAACgD,YAAT,IAAyBhD,QAAQ,CAACiD,SAAtC,EAAiD;IAC7CjD,QAAQ,CAACgD,YAAT,IAAyBT,KAAK,CAACW,KAA/B;IACA;EACH;;EACD,MAAML,IAAI,GAAG,CAACL,EAAE,GAAGxC,QAAQ,CAACmD,aAAf,MAAkC,IAAlC,IAA0CX,EAAE,KAAK,KAAK,CAAtD,GAA0D,KAAK,CAA/D,GAAmEA,EAAE,CAACY,QAAH,CAAYpD,QAAZ,CAAhF;;EACA,IAAI6C,IAAJ,EAAU;IACN7C,QAAQ,CAACgB,QAAT,CAAkBqC,KAAlB,CAAwBR,IAAxB;EACH;;EACD,IAAIF,WAAW,CAAC/C,KAAhB,EAAuB;IACnBI,QAAQ,CAACgB,QAAT,CAAkBC,CAAlB,GAAsBrB,KAAK,CAACI,QAAQ,CAACgB,QAAT,CAAkBC,CAAnB,EAAsB,CAAC,CAAvB,EAA0B,CAA1B,CAA3B;IACAjB,QAAQ,CAACgB,QAAT,CAAkBE,CAAlB,GAAsBtB,KAAK,CAACI,QAAQ,CAACgB,QAAT,CAAkBE,CAAnB,EAAsB,CAAC,CAAvB,EAA0B,CAA1B,CAA3B;EACH;;EACDlB,QAAQ,CAACgD,YAAT,IAAyBhD,QAAQ,CAACiD,SAAlC;AACH;AACD,OAAO,SAASK,uBAAT,CAAiCtD,QAAjC,EAA2C;EAC9C,OAAOA,QAAQ,CAACuD,IAAT,CAAcC,OAAd,GAAwBxD,QAAQ,CAACuD,IAAT,CAAcE,MAAtC,GAA+C,CAAtD;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}